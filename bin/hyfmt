#!/usr/bin/env hy
(import
  re)
(import
  argparse
  [ArgumentParser])
(require
  hyrule
  [->
    ->>
    as->
    block
    ap-map
    case])
(import
  hyrule
  [inc
    dec])
(setv
  TOKEN_IDENTIFIER
  "Identifier"
  TOKEN_PUNCTUATION
  "Punctuation"
  TOKEN_WHITESPACE
  "Whitespace"
  TOKEN_NEWLINE
  "Newline"
  TOKEN_STRING
  "String"
  TOKEN_BRACKET_STRING
  "BracketString"
  TOKEN_COMMENT
  "Comment"
  TOKEN_SHEBANG
  "Shebang")
(setv
  Whitespace
  (re.compile
    r"[ \t]+"))
(setv
  Newline
  (re.compile
    r"\n"))
(setv
  Identifier
  (re.compile
    r"[0-9a-zA-Z_\-+><=?.:*]+"))
(setv
  String
  (re.compile
    r"r?\"([^\\\"]|\\.)*\""))
(setv
  Punctuation
  (re.compile
    r"[\{\}\[\]\(\)]"))
(setv
  BracketStringStart
  (re.compile
    r"#\[(\w*)\["))
(setv
  Comment
  (re.compile
    r";.*"))
(defn
  empty?
  [x]
  (if
    x
    False
    True))
(defn
  first
  [x]
  (if
    (empty?
      x)
    None
    (get
      x
      0)))
(defn
  last
  [x]
  (if
    (empty?
      x)
    None
    (get
      x
      -1)))
(defn
  tokenize
  [input]
  (setv
    tokens
    [])
  (when
    (input.startswith
      "#!")
    (setv
      line-idx
      (input.find
        "\n"))
    (when
      (=
        -1
        line-idx)
      (setv
        line-idx
        (len
          input)))
    (setv
      val
      (cut
        input
        line-idx))
    (tokens.append
      (dict
        :type
        TOKEN_SHEBANG
        :val
        val))
    (setv
      input
      (cut
        input
        line-idx
        None)))
  (while
    input
    (setv
      res
      None)
    (when
      (not
        res)
      (setv
        res
        (BracketStringStart.match
          input))
      (when
        res
        (setv
          tag
          (res.group
            1))
        (setv
          pos-start
          (input.find
            (+
              "]"
              tag
              "]")))
        (if
          (=
            -1
            pos-start)
          (setv
            pos-end
            (len
              input))
          (setv
            pos-end
            (+
              pos-start
              (len
                (+
                  "]"
                  tag
                  "]")))))
        (setv
          content
          (cut
            input
            (.start
              res)
            pos-end))
        (tokens.append
          (dict
            :type
            TOKEN_BRACKET_STRING
            :val
            content))
        (setv
          input
          (cut
            input
            pos-end
            None))
        (continue)))
    (for
      [c
        [[Comment
            TOKEN_COMMENT]
          [Newline
            TOKEN_NEWLINE]
          [Whitespace
            TOKEN_WHITESPACE]
          [Punctuation
            TOKEN_PUNCTUATION]
          [String
            TOKEN_STRING]
          [Identifier
            TOKEN_IDENTIFIER]]]
      (setv
        res
        (.match
          (get
            c
            0)
          input))
      (when
        res
        (tokens.append
          (dict
            :type
            (get
              c
              1)
            :val
            (.group
              res)))
        (setv
          input
          (cut
            input
            (.end
              res)
            None))
        (break)))
    (when
      (not
        res)
      (raise
        (Exception
          f
          "Unexpected input: {input}"))))
  tokens)
(defn
  print-tokens
  [tokens]
  (setv
    res
    "")
  (setv
    arg-idx-stack
    [0])
  (defn
    get-arg-idx
    []
    (if
      (empty?
        arg-idx-stack)
      0
      (last
        arg-idx-stack)))
  (setv
    indent
    0)
  (defn
    get-indent-space
    []
    (*
      " "
      indent))
  (for
    [token
      tokens]
    (case
      (get
        token
        "type")
      TOKEN_SHEBANG
      (setv
        res
        (+
          res
          (get
            token
            "val")
          "\n"
          (get-indent-space)))
      TOKEN_COMMENT
      (setv
        res
        (+
          res
          (get
            token
            "val")
          "\n"
          (get-indent-space)));; TOKEN_NEWLINE (setv res (+ res (get token "val") (get-indent-space)))
      
      TOKEN_PUNCTUATION
      (let
        [arg-idx
          (get-arg-idx)
          val
          (get
            token
            "val")]
        (cond
          (in
            val
            ["("
              "["
              "{"])
          (do
            (when
              (>
                arg-idx
                0)
              (setv
                res
                (+
                  res
                  "\n"
                  (get-indent-space))))
            (setv
              res
              (+
                res
                val))
            (setv
              (get
                arg-idx-stack
                -1)
              (inc
                arg-idx))
            (arg-idx-stack.append
              0)
            (setv
              indent
              (+
                indent
                2)))
          (in
            val
            [")"
              "]"
              "}"])
          (do
            (setv
              res
              (+
                res
                val))
            (.pop
              arg-idx-stack)
            (setv
              indent
              (-
                indent
                2)))
          True
          (raise
            (Exception
              f
              "Unexpected punctuation: {val}"))))
      TOKEN_STRING
      (let
        [arg-idx
          (get-arg-idx)
          val
          (get
            token
            "val")]
        (when
          (>
            arg-idx
            0)
          (setv
            res
            (+
              res
              "\n"
              (get-indent-space))))
        (setv
          res
          (+
            res
            val))
        (setv
          (get
            arg-idx-stack
            -1)
          (inc
            arg-idx)))
      TOKEN_IDENTIFIER
      (let
        [arg-idx
          (get-arg-idx)
          val
          (get
            token
            "val")]
        (when
          (>
            arg-idx
            0)
          (setv
            res
            (+
              res
              "\n"
              (get-indent-space))))
        (setv
          res
          (+
            res
            val))
        (setv
          (get
            arg-idx-stack
            -1)
          (inc
            arg-idx)))
      TOKEN_BRACKET_STRING
      (let
        [arg-idx
          (get-arg-idx)
          val
          (get
            token
            "val")]
        (when
          (>
            arg-idx
            0)
          (setv
            res
            (+
              res
              "\n"
              (get-indent-space))))
        (setv
          res
          (+
            res
            val))
        (setv
          (get
            arg-idx-stack
            -1)
          (inc
            arg-idx)));; TOKEN_WHITESPACE "Whitespace"
      ))
  res)
(let
  [parser
    (ArgumentParser)]
  (.add_argument
    parser
    "path"
    :nargs
    "*")
  (.add_argument
    parser
    "-w"
    :action
    "store_true")
  (setv
    args
    (.parse_args
      parser))
  (for
    [path
      args.path]
    (with
      [f
        (open
          path
          (if
            args.w
            "r+"
            "r"))]
      (setv
        code
        (.read
          f))
      (setv
        formatted
        (print-tokens
          (tokenize
            code)))
      (if
        args.w
        (do
          (.seek
            f
            0)
          (.write
            f
            formatted))
        (print
          formatted)))))